(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{332:function(e,a,v){"use strict";v.r(a);var _=v(41),t=Object(_.a)({},(function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[v("em",[e._v("本文翻译自")]),e._v(" "),v("a",{attrs:{href:"https://arend-lang.github.io/documentation/tutorial/PartI/idtype",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arend Tutorial, Part I, Equality"),v("OutboundLink")],1),e._v(" "),v("em",[e._v("，原作者为 "),v("a",{attrs:{href:"https://github.com/arend-lang",target:"_blank",rel:"noopener noreferrer"}},[e._v("JetBrains Research HoTT and Dependent Types Group (F. Part, V. Isaev and S. Sinchuk)"),v("OutboundLink")],1),e._v("。原作品在 Apache 2.0 协议下发表。")])]),e._v(" "),v("p",[e._v("在上一章中我们以一种相当粗略的方式对待相等类型，因为我们基本上只用到了自反性 "),v("code",[e._v("idp {A : \\Type} {a : A} : a = a")]),e._v("。本章中我们会更加深入地讨论相等类型的定义细节，进而解释一些书写更高级的证明所必需的关键概念。具体来讲，我们将会介绍"),v("em",[e._v("区间类型")]),e._v(" "),v("code",[e._v("I")]),e._v("；它的本质是被函数 "),v("code",[e._v("coe")]),e._v(" （这是 "),v("code",[e._v("I")]),e._v(" 的"),v("em",[e._v("析构器")]),e._v("）决定的。为了描述得清楚一点，我们还会简短介绍一下什么是析构器。")]),e._v(" "),v("h1",{attrs:{id:"对称、传递和-leibniz-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对称、传递和-leibniz-原理"}},[e._v("#")]),e._v(" 对称、传递和 Leibniz 原理")]),e._v(" "),v("p",[e._v("首先我们来证明，相等类型满足相等性的一些基本性质：")]),e._v(" "),v("ul",[v("li",[e._v("它是一个等价关系；")]),e._v(" "),v("li",[e._v("它满足 Leibniz 原理。")])]),e._v(" "),v("p",[e._v("Leibniz 原理就是说，如果 "),v("code",[e._v("a")]),e._v(" 和 "),v("code",[e._v("a'")]),e._v(" 满足相同的性质，那么它们就相等。我们可以很容易地证明 "),v("code",[e._v("=")]),e._v(" 满足这个原理：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func Leibniz {A : \\Type} {a a' : A}\n  (f : \\Pi (P : A -> \\Type) -> \\Sigma (P a -> P a') (P a' -> P a)) : a = a'\n  => (f (\\lam x => a = x)).1 idp\n")])])]),v("p",[e._v("逆 Leibniz 原理（也可以只叫成 Leibniz 原理）是说，如果 "),v("code",[e._v("a = a'")]),e._v("，那么 "),v("code",[e._v("a")]),e._v(" 和 "),v("code",[e._v("a'")]),e._v(" 必定满足相同的性质。也就是说，如果 "),v("code",[e._v("P a")]),e._v(" 是真的，那么 "),v("code",[e._v("P a'")]),e._v(" 也是真的。证明这个东西很简单，但是会用到我们一会儿才会介绍的一些构造：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a'\n    => coe (\\lam i => B (p @ i)) b right\n")])])]),v("p",[e._v("通过逆 Leibniz 原理，我们可以很容易地证明 "),v("code",[e._v("=")]),e._v(" 满足几乎所有相等性的性质。比如说，我们可以证明：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("-- symmetry\n\\func inv {A : \\Type} {a a' : A} (p : a = a') : a' = a\n    => transport (\\lam x => x = a) p idp\n\n-- transitivity\n\\func trans {A : \\Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a''\n    => transport (\\lam x => a = x) q p\n\n-- congruence\n\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a'\n    => transport (\\lam x => f a = f x) p idp\n")])])]),v("blockquote",[v("p",[e._v("练习 1：用 "),v("code",[e._v("transport")]),e._v(" 定义接受两个参数的函数的合同性。你也可以利用其他任何通过 "),v("code",[e._v("transport")]),e._v(" 定义出的函数。")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 2：证明用 "),v("code",[e._v("pmap")]),e._v(" 和 "),v("code",[e._v("repl")]),e._v(" 可以定义出 "),v("code",[e._v("transport")]),e._v("，反之亦然。函数 "),v("code",[e._v("repl")]),e._v(" 就是说，如果两个类型相等，那么它们之间有一个函数。")])]),e._v(" "),v("h1",{attrs:{id:"的定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#的定义"}},[e._v("#")]),e._v(" "),v("code",[e._v("=")]),e._v(" 的定义")]),e._v(" "),v("p",[e._v("相等类型的一个重要部分是 Prelude 里的"),v("em",[e._v("区间类型")]),e._v(" "),v("code",[e._v("I")]),e._v("。你可能会觉得 "),v("code",[e._v("I")]),e._v(" 看起来像个只有两个元素 "),v("code",[e._v("left")]),e._v(" 和 "),v("code",[e._v("right")]),e._v(" 的数据类型，但是你错了。这些构造器通过 "),v("code",[e._v("coe")]),e._v(" 被定义成了相等的。而且我们（理所应当地）禁止在 "),v("code",[e._v("I")]),e._v(" 上进行模式匹配，不然的话我们就可以证明 "),v("code",[e._v("Empty = Unit")]),e._v(" 了。")]),e._v(" "),v("p",[v("code",[e._v("left = right")]),e._v(" 这个相等性蕴涵了这样一个事实：某个 "),v("code",[e._v("a : A")]),e._v(" 和 "),v("code",[e._v("a' : A")]),e._v(" 相等，当且仅当存在一个函数 "),v("code",[e._v("f : I -> A")]),e._v(" 使得 "),v("code",[e._v("f left ==> a")]),e._v(" 而且 "),v("code",[e._v("f right ==> a'")]),e._v("（"),v("code",[e._v("==>")]),e._v(" 代表计算相等性）。")]),e._v(" "),v("blockquote",[v("p",[e._v("（译注：这是因为，我们可以把 "),v("code",[e._v("pmap f")]),e._v(" 应用到 "),v("code",[e._v("left = right")]),e._v(" 上，进而得到 "),v("code",[e._v("a = a'")]),e._v("。）")])]),e._v(" "),v("p",[e._v("类型 "),v("code",[e._v("a = {A} a'")]),e._v(" 事实上就是所有这种函数的类型。构造器 "),v("code",[e._v("path (f : I -> A) : f left = f right")]),e._v(" 可以用来从这种函数中构造相等性的证明，而函数 "),v("code",[e._v("@ (p : a = a') (i : I) : A")]),e._v(" 可以做相反的事情：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("path f @ i ==> f i -- beta 等价性\npath (\\lam i => p @ i) ==> p -- eta 等价性\n")])])]),v("p",[e._v("要证明自反性 "),v("code",[e._v("idp")]),e._v(" 的话我们只需要常量函数 "),v("code",[e._v("\\lam _ => a : I -> A")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func idp {A : \\Type} {a : A} : a = a => path (\\lam _ => a)\n")])])]),v("blockquote",[v("p",[e._v("练习 3：不用 "),v("code",[e._v("transport")]),e._v(" 和 "),v("code",[e._v("coe")]),e._v(" 来证明 "),v("code",[e._v("left = right")]),e._v("。")])]),e._v(" "),v("p",[e._v("如果 "),v("code",[e._v("f : A -> B")]),e._v(" 并且 "),v("code",[e._v("g : I -> A")]),e._v("，那么 "),v("code",[e._v("g")]),e._v(" 就是相等性 "),v("code",[e._v("g left = g right")]),e._v(" 的证明，而 "),v("code",[e._v("pmap")]),e._v(" 可以理解成 "),v("code",[e._v("f")]),e._v(" 和 "),v("code",[e._v("g")]),e._v(" 的复合函数。注意到这两点之后，我们就可以用另一种方法定义 "),v("code",[e._v("pmap")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a'\n    => path (\\lam i => f (p @ i))\n")])])]),v("p",[e._v("这种 "),v("code",[e._v("pmap")]),e._v(" 在计算的性质上比其他 "),v("code",[e._v("pmap")]),e._v(" 表现更好。比如说，"),v("code",[e._v("pmap id")]),e._v(" 可以直接被计算成 "),v("code",[e._v("id")]),e._v("，而 "),v("code",[e._v("pmap (f . g)")]),e._v(" 会直接被计算成 "),v("code",[e._v("pmap f . pmap g")]),e._v("（"),v("code",[e._v(".")]),e._v(" 是函数复合）：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func pmap-idp {A : \\Type} {a a' : A} (p : a = a') : pmap {A} (\\lam x => x) p = p\n    => idp\n")])])]),v("blockquote",[v("p",[e._v("练习 4：不用 "),v("code",[e._v("transport")]),e._v(" 证明 "),v("code",[e._v("a = {A} a'")]),e._v(" 与 "),v("code",[e._v("b = {B} b'")]),e._v(" 蕴涵了 "),v("code",[e._v("(a, b) = {\\Sigma A B} (a', b')")]),e._v("。")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 5：不用 "),v("code",[e._v("transport")]),e._v(" 证明 "),v("code",[e._v("p = {\\Sigma (x : A) (B x)} p'")]),e._v(" 蕴涵了 "),v("code",[e._v("p.1 = {A} p'.1")]),e._v("。")])]),e._v(" "),v("h1",{attrs:{id:"函数外延性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数外延性"}},[e._v("#")]),e._v(" 函数外延性")]),e._v(" "),v("p",[e._v("函数外延性就是说，如果对于任何值，"),v("code",[e._v("f")]),e._v(" 和 "),v("code",[e._v("g")]),e._v(" 应用后的结果都相同，那么它们就是相等的函数。用我们定义的相等性来证明这条原理非常简单：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func funExt {A : \\Type} (B : A -> \\Type) {f g : \\Pi (a : A) -> B a}\n    (p : \\Pi (a : A) -> f a = g a) : f = g\n    => path (\\lam i => \\lam a => p a @ i)\n")])])]),v("p",[e._v("这条原理在其他很多内涵类型论里都没法证明。那些理论中函数的外延性是作为一条公理引入的，而公理是一个没有具体实现的函数。然而，向理论里添加公理会损害它的计算性质。比如说，如果我们添加排中律 "),v("code",[e._v("lem")]),e._v(" 作为一条公理，那么我们就可以定义一个没法归约到任何自然数的常数 "),v("code",[e._v("ugly_num")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func lem : \\Pi (X : \\Type) -> Either X (X -> Empty) => {?}\n\\func ugly_num : Nat => \\case lem Nat \\with { | Left => 0 | Right => 1 }\n")])])]),v("blockquote",[v("p",[e._v("练习 6：证明 "),v("code",[e._v("(\\lam x => not (not x)) = (\\lam x => x)")]),e._v("。")])]),e._v(" "),v("h1",{attrs:{id:"析构器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#析构器"}},[e._v("#")]),e._v(" 析构器")]),e._v(" "),v("p",[e._v("对于一个数据类型 "),v("code",[e._v("D")]),e._v("，它的消去原理定义了我们在构造一个从 "),v("code",[e._v("D")]),e._v(" 到其他依赖或不依赖于 "),v("code",[e._v("D")]),e._v(" 的类型的函数时需要提供哪种数据。更重要的是，这些原理表明了，如果我们可以说明如何把 "),v("code",[e._v("D")]),e._v(" 的『生成器』（也就是构造器）映射到类型 "),v("code",[e._v("A")]),e._v("，那么我们就可以唯一确定一个函数 "),v("code",[e._v("D -> A")]),e._v("。比方说，"),v("code",[e._v("Nat")]),e._v(" 和 "),v("code",[e._v("Bool")]),e._v(" 的析构器：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("-- Nat 的依赖析构器（归纳法）。\n\\func Nat-elim (P : Nat -> \\Type)\n               (z : P zero)\n               (s : \\Pi (n : Nat) -> P n -> P (suc n))\n               (x : Nat) : P x \\elim x\n  | zero => z\n  | suc n => s n (Nat-elim P z s n)\n\n-- Nat 的非依赖析构器（递归）。\n\\func Nat-rec (P : \\Type)\n              (z : P)\n              (s : Nat -> P -> P)\n              (x : Nat) : P \\elim x\n  | zero => z\n  | suc n => s n (Nat-rec P z s n)\n\n-- Bool 的依赖析构器（也就是 `if`）。\n\\func Bool-elim (P : Bool -> \\Type)\n                (t : P true)\n                (f : P false)\n                (x : Bool) : P x \\elim x\n  | true => t\n  | false => f\n")])])]),v("blockquote",[v("p",[e._v("练习 7：不用递归和模式匹配，而用 "),v("code",[e._v("Nat-rec")]),e._v(" 定义阶乘。")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 8：不用递归和模式匹配，而用 "),v("code",[e._v("Nat-elim")]),e._v(" 证明 "),v("code",[e._v("Nat.+")]),e._v(" 的结合律。")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 9：定义 "),v("code",[e._v("\\data D | con1 Nat | con2 D D | con3 (Nat -> D)")]),e._v(" 的递归器和析构器。（译注：『析构器』指的是依赖析构器，『递归器』指的是非依赖的析构器。）")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 10：定义 "),v("code",[e._v("List")]),e._v(" 的递归器和析构器。")])]),e._v(" "),v("p",[e._v("而 "),v("code",[e._v("coe")]),e._v(" 就定义了 "),v("code",[e._v("I")]),e._v(" 的依赖析构器，也就是说对于某个 "),v("code",[e._v("P : I -> \\Type")]),e._v("，如果我们要定义 "),v("code",[e._v("f : \\Pi (i : I) -> P i")]),e._v(" 的话，给出 "),v("code",[e._v("f left")]),e._v(" 就足够了：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func coe (P : I -> \\Type)\n          (a : P left)\n          (i : I) : P i \\elim i\n  | left => a\n")])])]),v("blockquote",[v("p",[e._v("练习 11：我们用 "),v("code",[e._v("coe")]),e._v(" 定义了 "),v("code",[e._v("transport")]),e._v("。我们还可以用 "),v("code",[e._v("transport")]),e._v(" 定义 "),v("code",[e._v("coe")]),e._v(" 的一个特殊情况。用 "),v("code",[e._v("transport")]),e._v(" 定义 "),v("code",[e._v("coe0 (A : I -> \\Type) (a : A left) : A right")]),e._v("，并思考是否反之亦然。")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 12：定义一个函数 "),v("code",[e._v("B right -> B left")]),e._v("。")])]),e._v(" "),v("h1",{attrs:{id:"left-right"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#left-right"}},[e._v("#")]),e._v(" "),v("code",[e._v("left = right")])]),e._v(" "),v("p",[e._v("通过 "),v("code",[e._v("coe")]),e._v(" 我们可以证明，"),v("code",[e._v("I")]),e._v(" 只有一个元素：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func left=i (i : I) : left = i\n  -- | left => idp\n  => coe (\\lam i => left = i) idp i\n\n-- 特别地，left = right。\n\\func left=right : left = right => left=i right\n")])])]),v("h1",{attrs:{id:"coe-和-transport"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#coe-和-transport"}},[e._v("#")]),e._v(" "),v("code",[e._v("coe")]),e._v(" 和 "),v("code",[e._v("transport")])]),e._v(" "),v("p",[e._v("函数 "),v("code",[e._v("coe")]),e._v(" 和 "),v("code",[e._v("transport")]),e._v(" 紧密相关。回忆一下，本章中 "),v("code",[e._v("transport")]),e._v(" 的定义是：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a'\n     => coe (\\lam i => B (p @ i)) b right\n")])])]),v("p",[e._v("令 "),v("code",[e._v("B'")]),e._v(" 表示 "),v("code",[e._v("\\lam i => B (p @ i)")]),e._v("。于是 "),v("code",[e._v("B' : I -> \\Type")]),e._v("，"),v("code",[e._v("B' left ==> B a")]),e._v("，"),v("code",[e._v("B' right ==> B a'")]),e._v(" 并且 "),v("code",[e._v("\\lam x => coe B' x right : B' left -> B' right")]),e._v("。")]),e._v(" "),v("h1",{attrs:{id:"不等性的证明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不等性的证明"}},[e._v("#")]),e._v(" 不等性的证明")]),e._v(" "),v("p",[e._v("要证明 "),v("code",[e._v("true")]),e._v(" 不等于 "),v("code",[e._v("false")]),e._v("，我们可以定义一个函数 "),v("code",[e._v("T : Bool -> \\Type")]),e._v(" 使得 "),v("code",[e._v("T true")]),e._v(" 是单元类型而 "),v("code",[e._v("T false")]),e._v(" 是空类型。接着我们可以很容易通过 "),v("code",[e._v("true = false")]),e._v(" 用 "),v("code",[e._v("transport")]),e._v(" 推导出矛盾：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\\func true/=false (p : true = false) : Empty => transport T p unit\n")])])]),v("p",[e._v("注意我们不可能通过这个证明 "),v("code",[e._v("left")]),e._v(" 不等于 "),v("code",[e._v("right")]),e._v("，因为我们不能对 "),v("code",[e._v("I")]),e._v(" 归纳定义 "),v("code",[e._v("T")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language-arend extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("-- 这个函数没法通过类型检查\n\\func TI (b : I)\n  | left => \\Sigma\n  | right => Empty\n")])])]),v("blockquote",[v("p",[e._v("练习 13：证明 "),v("code",[e._v("0")]),e._v(" 不等于 "),v("code",[e._v("suc x")]),e._v("。")])]),e._v(" "),v("blockquote",[v("p",[e._v("练习 14：证明 "),v("code",[e._v("fac")]),e._v(" 不等于 "),v("code",[e._v("suc")]),e._v("。")])])])}),[],!1,null,null,null);a.default=t.exports}}]);