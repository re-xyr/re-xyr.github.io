(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{330:function(e,v,_){"use strict";_.r(v);var t=_(41),o=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[_("em",[e._v("本文翻译自")]),e._v(" "),_("a",{attrs:{href:"https://arend-lang.github.io/documentation/tutorial/PartI/propsnproofs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arend Tutorial, Part I, Propositions and Proofs"),_("OutboundLink")],1),e._v(" "),_("em",[e._v("，原作者为 "),_("a",{attrs:{href:"https://github.com/arend-lang",target:"_blank",rel:"noopener noreferrer"}},[e._v("JetBrains Research HoTT and Dependent Types Group (V. Isaev, F. Part and S. Sinchuk)"),_("OutboundLink")],1),e._v("。原作品在 Apache 2.0 协议下发表。")])]),e._v(" "),_("p",[e._v("在本章中，我们将介绍如何在 Arend 中表述并证明命题。我们会展示表达若干逻辑连接词的方法，并说明他们是如何满足特定的性质的。")]),e._v(" "),_("h1",{attrs:{id:"curry-howard-对应"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#curry-howard-对应"}},[e._v("#")]),e._v(" Curry-Howard 对应")]),e._v(" "),_("p",[e._v("Arend 是基于 Martin-Lof 类型论的一个变种而开发的。这类理论中并不存在一种专门用来表达命题和证明的逻辑语言。相反地，他们通过 Curry-Howard 对应来将命题编码为类型。假命题对应的是空类型，而真命题对应的是单元类型。一个类型的不同元素可以被认为是证明一个命题的不同方法。举个例子，自然数类型就对应了「自然数存在」这个命题，而这个类型的每个元素就是这个命题的一个证明。")]),e._v(" "),_("blockquote",[_("p",[e._v("注意：这个对应关系会在本教程的"),_("a",{attrs:{href:""}},[e._v("第二部分")]),e._v("被更为精确地阐述，到时候我们会看到并不是每个类型都应该被看作一个命题。")])]),e._v(" "),_("p",[e._v("我们现在来展示空类型 "),_("code",[e._v("Empty")]),e._v(" 如何对应到逻辑假。因为我们可以从 "),_("code",[e._v("Empty")]),e._v(" 的一个元素构造出任何类型的元素，所以我们可以证明逻辑假蕴涵了任何命题：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func absurd {A : \\Type} (e : Empty) : A\n-- 这个定义里没有任何模式，因为 Empty 没有构造器。\n\n-- 我们也可以通过荒谬模式来更加显式地表达这个定义。\n-- 荒谬模式表明了某个变量所属的数据类型并没有任何构造器。\n-- 如果使用了这个模式，那么这个子句的右手边应该被省略掉。\n\\func absurd' {A : \\Type} (e : Empty) : A \\elim e\n  | () -- 荒谬模式\n")])])]),_("p",[e._v("当然，我们也可以证明 "),_("code",[e._v("Unit")]),e._v(" 类型对应到了逻辑真。这只需要我们构造这个类型的一个值：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func Unit-isTrue : Unit => Unit\n")])])]),_("p",[e._v("要表述更加复杂的命题，我们需要定义若干种逻辑连接词，比如合取 "),_("code",[e._v("&&")]),e._v("、析取 "),_("code",[e._v("||")]),e._v("、蕴涵 "),_("code",[e._v("->")]),e._v(" 和否定 "),_("code",[e._v("Not")]),e._v("。我们先从蕴涵开始。如果 "),_("code",[e._v("P -> Q")]),e._v(" 为真，那么 "),_("code",[e._v("P")]),e._v(" 为真就蕴涵了（或表明了） "),_("code",[e._v("Q")]),e._v(" 为真。那么，我们可以把 "),_("code",[e._v("P -> Q")]),e._v(" 的证明看作一个将 "),_("code",[e._v("P")]),e._v(" 的证明转换为 "),_("code",[e._v("Q")]),e._v(" 的证明的函数。换言说，对应到逻辑蕴涵的类型就是函数类型 "),_("code",[e._v("P -> Q")]),e._v("。")]),e._v(" "),_("p",[e._v("现在，我们已经可以证明许多重言式的命题了。举个例子，恒等函数证明了对于所有命题 "),_("code",[e._v("P")]),e._v("，"),_("code",[e._v("P -> P")]),e._v(" 成立；常量函数 "),_("code",[e._v("\\lam x y => x")]),e._v(" 证明了 "),_("code",[e._v("P -> Q -> P")]),e._v("；组合函数 "),_("code",[e._v("\\lam g f x => g (f x)")]),e._v(" 证明了 "),_("code",[e._v("(Q -> S) -> (P -> Q) -> P -> S")]),e._v("。")]),e._v(" "),_("blockquote",[_("p",[e._v("练习 1：证明 "),_("code",[e._v("(P -> Q -> R) -> (P -> Q) -> P -> R")]),e._v("。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 2：证明 "),_("code",[e._v("((P -> Q -> R) -> P) -> (P -> R) -> R")]),e._v("。")])]),e._v(" "),_("p",[e._v("因为 "),_("code",[e._v("P && Q")]),e._v(" 为真当且仅当 "),_("code",[e._v("P")]),e._v(" 为真且 "),_("code",[e._v("Q")]),e._v(" 为真，所以我们可以把 "),_("code",[e._v("P && Q")]),e._v(" 的一个证明看作一个对，其中包含一个 "),_("code",[e._v("P")]),e._v(" 的证明和一个 "),_("code",[e._v("Q")]),e._v(" 的证明。换言说，对应到 "),_("code",[e._v("P && Q")]),e._v(" 的类型就是对类型：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func \\infixr 3 && (P Q : \\Type) => \\Sigma P Q\n")])])]),_("p",[e._v("证明合取公理很简单：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("-- 这个函数证明了 P -> Q -> (P && Q)\n\\func &&-intro {P Q : \\Type} (p : P) (q : Q) : \\Sigma P Q => (p, q)\n\n-- 这个函数证明了 (P && Q) -> P\n\\func &&-elim1 {P Q : \\Type} (t : \\Sigma P Q) : P => t.1\n\n-- 这个函数证明了 (P && Q) -> Q\n\\func &&-elim2 {P Q : \\Type} (t : \\Sigma P Q) : Q => t.2\n")])])]),_("p",[_("code",[e._v("P || Q")]),e._v(" 的一个证明要么是 "),_("code",[e._v("P")]),e._v(" 的证明，要么是 "),_("code",[e._v("Q")]),e._v(" 的证明。所以，这个连接词对应到的类型是和类型：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\data \\infixr 2 || (P Q : \\Type)\n  | inl P\n  | inr Q\n")])])]),_("p",[e._v("证明析取公理也很简单：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("-- 这个函数证明了 P -> (P || Q)\n\\func ||-intro1 {P Q : \\Type} (p : P) : P || Q => inl p\n\n-- 这个函数证明了 Q -> (P || Q)\n\\func ||-intro2 {P Q : \\Type} (q : Q) : P || Q => inr q\n\n-- 这个函数证明了 (P -> R) -> (Q -> R) -> (P || Q) -> R\n\\func ||-elim {P Q R : \\Type} (l : P -> R) (r : Q -> R) (x : P || Q) : R \\elim x\n  | inl p => l p\n  | inr q => r q\n")])])]),_("blockquote",[_("p",[e._v("练习 5：证明 "),_("code",[e._v("(P -> R) -> (Q -> R) -> P || Q -> R")]),e._v("。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 6：证明 "),_("code",[e._v("((P || Q) -> (P && Q)) -> ((P -> Q) && (Q -> P))")]),e._v("。")])]),e._v(" "),_("p",[e._v("否定类型 "),_("code",[e._v("Not P")]),e._v(" 可以用逻辑蕴涵定义为 "),_("code",[e._v("P -> Empty")]),e._v("。")]),e._v(" "),_("blockquote",[_("p",[e._v("注意：Arend 使用的逻辑是直觉逻辑。也就是说，排中律、双重否定的消去以及其他在经典逻辑中有效的定律在 Arend 中是无法证明的。这是因为在直觉逻辑中，合取 "),_("code",[e._v("P && Q")]),e._v(" 并不能表达成 "),_("code",[e._v("Not (Not P || Not Q)")]),e._v("，析取 "),_("code",[e._v("P || Q")]),e._v(" 不能表达成 "),_("code",[e._v("Not (Not P && Not Q)")]),e._v("，蕴涵 "),_("code",[e._v("P -> Q")]),e._v(" 也不能表达成 "),_("code",[e._v("Not P || Q")]),e._v("。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 7：罗素悖论表明了不存在「所有集合」的集合。如果这个集合存在，那么我们就可以构造集合 "),_("code",[e._v("B")]),e._v("，其中包含「所有不包含自身的集合」。于是，"),_("code",[e._v("B")]),e._v(" 属于 "),_("code",[e._v("B")]),e._v(" 当且仅当他不属于 "),_("code",[e._v("B")]),e._v("，而这显然蕴涵了矛盾。康托尔定理表明不存在从集合 "),_("code",[e._v("X")]),e._v(" 到其幂集的满射。他的证明同样构造了一个命题，这个命题为真当且仅当他为假。试证明任意一个这种命题都蕴涵了矛盾。")])]),e._v(" "),_("p",[e._v("我们现在来讨论量词。命题 "),_("code",[e._v("forall (x : A). P(x)")]),e._v(" 的证明应该对于 "),_("code",[e._v("A")]),e._v(" 类型的任意元素 "),_("code",[e._v("a")]),e._v(" 都能给出 "),_("code",[e._v("P(a)")]),e._v(" 的证明。因此，这个命题对应到了依赖函数类型 "),_("code",[e._v("\\Pi (x : A) -> P x")]),e._v("。命题 "),_("code",[e._v("exists (x : A). P(x)")]),e._v(" 应当能够给出 "),_("code",[e._v("A")]),e._v(" 的某个元素 "),_("code",[e._v("a")]),e._v(" 和一个 "),_("code",[e._v("P(a)")]),e._v(" 成立的证明。因此，这个命题对应到了依赖对类型 "),_("code",[e._v("\\Sigma (x : A) (P x)")]),e._v("。")]),e._v(" "),_("blockquote",[_("p",[e._v("练习 8：证明如果对于所有 "),_("code",[e._v("x : Nat")]),e._v(" 有 "),_("code",[e._v("P x")]),e._v(" 成立，那么存在某个 "),_("code",[e._v("x : Nat")]),e._v(" 使得 "),_("code",[e._v("P x")]),e._v(" 为真。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 9：证明如果不存在 "),_("code",[e._v("x : Nat")]),e._v(" 使得 "),_("code",[e._v("P x")]),e._v(" 为真，那么 "),_("code",[e._v("P 3")]),e._v(" 为假。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 10：证明如果对于所有 "),_("code",[e._v("x : Nat")]),e._v("，"),_("code",[e._v("P x")]),e._v(" 都蕴涵了 "),_("code",[e._v("Q x")]),e._v("，那么命题「存在某个 "),_("code",[e._v("x : Nat")]),e._v(" 使得 "),_("code",[e._v("P x")]),e._v(" 为真」蕴涵了「存在某个 "),_("code",[e._v("x : Nat")]),e._v(" 使得 "),_("code",[e._v("Q x")]),e._v(" 为真」。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 11：证明如果对于所有 "),_("code",[e._v("x : Nat")]),e._v(" 要么 "),_("code",[e._v("P x")]),e._v(" 为假要么 "),_("code",[e._v("Q x")]),e._v(" 为假，那么 "),_("code",[e._v("P 3")]),e._v(" 蕴涵了 "),_("code",[e._v("Q 3")]),e._v(" 为假。")])]),e._v(" "),_("h1",{attrs:{id:"命题和证明的几个例子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#命题和证明的几个例子"}},[e._v("#")]),e._v(" 命题和证明的几个例子")]),e._v(" "),_("p",[e._v("下面是使用我们刚才谈到的内容进行命题和证明的几个例子。为了方便表达命题，我们定义一个函数 "),_("code",[e._v("T")]),e._v(" 来将 "),_("code",[e._v("true : Bool")]),e._v(" 映射到真命题（即 "),_("code",[e._v("Unit")]),e._v(" 类型）并将 "),_("code",[e._v("false : Bool")]),e._v(" 映射到假命题（即 "),_("code",[e._v("Empty")]),e._v(" 类型）：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func T (b : Bool) : \\Type\n  | true => Unit\n  | false => Empty\n")])])]),_("p",[e._v("接着我们来证明关于之前定义的 "),_("code",[e._v("Bool")]),e._v(" 类型的一些命题。要表达这些命题，我们需要先定义一个谓词来判定 "),_("code",[e._v("Bool")]),e._v(" 的相等关系：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func \\infix 4 == (x y : Bool) : Bool\n  | true, true => true\n  | false, false => true\n  | _ , _ => false\n")])])]),_("p",[e._v("接下来可以看到，命题 "),_("code",[e._v("T (x == x)")]),e._v(" 和 "),_("code",[e._v("T (not (not x) == x)")]),e._v(" 可以通过分类讨论来证明：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func not-isInvolution (x : Bool) : T (not (not x) == x)\n  | true => unit -- 如果 x 是 true，那么 T (not (not true) == true) 被计算为 Unit\n  | false => unit -- 如果 x 是 false，那么 T (not (not false) == false) 被计算为 Unit\n\n-- 相似地，证明 == 的自反性\n\\func ==-refl (x : Bool) : T (x == x)\n  | true => unit\n  | false => unit\n")])])]),_("p",[e._v("这两个证明中我们在任何一种情况下都直接返回了 "),_("code",[e._v("unit")]),e._v("。注意，我们不能去掉分类讨论而直接返回 "),_("code",[e._v("unit")]),e._v("，因为 "),_("code",[e._v("T (not (not x) == x)")]),e._v(" 和 "),_("code",[e._v("T (x == x)")]),e._v(" 不会被计算为 "),_("code",[e._v("Unit")]),e._v("。下面这段代码就不会通过类型检查：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func not-isInvolution' (x : Bool) : T (not (not x) == x) => unit\n")])])]),_("p",[e._v("用这种方式也不可能证明假命题：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func not-isIdempotent (x : Bool) : T (not (not x) == not x)\n  | true => {?} -- 这个目标表达式需要一个 Empty 类型的值\n  | false => {?} -- 这个目标表达式需要一个 Empty 类型的值\n\n-- 但我们可以证明 not-isIdempotent 的反命题\n\\func not-isIdempotent' (x : Bool) : T (not (not x) == not x) -> Empty\n  | true => \\lam x => x -- Empty -> Empty 的证明\n  | false => \\lam x => x -- Empty -> Empty 的证明\n")])])]),_("p",[e._v("我们也可以证明带有量词的命题。比如说，命题「对于所有 "),_("code",[e._v("x : Bool")]),e._v(" 都存在某个 "),_("code",[e._v("y : Bool")]),e._v(" 使得 x == y」：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("-- Sigma- 类型在这里用来表示存在量词\n\\func lemma (x : Bool) : \\Sigma (y : Bool) (T (x == y)) => (x, ==-refl x)\n")])])]),_("p",[e._v("下面是一个有点拗口的命题的证明：「如果所有 "),_("code",[e._v("x : Bool")]),e._v(" 都等于自身，那么 "),_("code",[e._v("true : Bool")]),e._v(" 等于 "),_("code",[e._v("true : Bool")]),e._v("。」")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func higherOrderFunc (f : \\Pi (x : Bool) -> T (x == x)) : T (true == true) => f true\n")])])]),_("h1",{attrs:{id:"相等类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相等类型"}},[e._v("#")]),e._v(" 相等类型")]),e._v(" "),_("p",[e._v("我们为 "),_("code",[e._v("Bool")]),e._v(" 定义的相等性 "),_("code",[e._v("==")]),e._v(" 并不能令人满意。这个定义只能作用于 "),_("code",[e._v("Bool")]),e._v("，而对于其他所有类型我们都要做出类似的定义，然后证明这是相等关系。")]),e._v(" "),_("p",[e._v("所以，我们并不这么做，而是定义一个对于所有类型的相等类型。这个定义已经包含在 Prelude 里了（即 "),_("code",[e._v("Path")]),e._v(" 类型和他的中缀表达 "),_("code",[e._v("=")]),e._v("）。我们不会马上深入讨论这个话题，因为现在我们只需要自反性的证明 "),_("code",[e._v("idp : a = a")]),e._v("，他同样也被包含在 Prelude 里了。")]),e._v(" "),_("p",[e._v("现在，所有通过 "),_("code",[e._v("==")]),e._v(" 证明的相等性也可以类似地通过 "),_("code",[e._v("=")]),e._v(" 证明。比如，等式 "),_("code",[e._v("not (not x) = x")]),e._v("：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func not-isInvolution'' (x : Bool) : not (not x) = x\n  | true => idp\n  | false => idp\n")])])]),_("p",[e._v("并且我们仍然不能证明假命题：")]),e._v(" "),_("div",{staticClass:"language-arend extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\\func not-isIdempotent'' (x : Bool) : not (not x) = not x\n  | true => {?} -- 这个目标表达式需要一个 true = false 的证明，这是不可能构造出来的\n  | false => {?} -- 这个目标表达式需要一个 false = true 的证明，这是不可能构造出来的\n")])])]),_("blockquote",[_("p",[e._v("练习 12：证明 "),_("code",[e._v("and")]),e._v(" 和 "),_("code",[e._v("or")]),e._v(" 的结合性。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 13：证明 2 * 2 等于 4。")])]),e._v(" "),_("blockquote",[_("p",[e._v("练习 14：证明列表串接的结合性。")])])])}),[],!1,null,null,null);v.default=o.exports}}]);